<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sparkpacketâ€™s Guide to the INTERNET!</title>
<style>
body {
  margin: 0;
  font-family: monospace;
  background: black;
  color: #00ff88;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  overflow: hidden;
}
#terminal {
  width: 100%;
  max-width: 900px;
  height: 100vh;
  padding: 1rem;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  overflow-y: auto;
  position: relative;
}
#header {
  font-size: 1.4rem;
  color: #00ffff;
  margin-bottom: 1rem;
  text-shadow: 0 0 6px #00ffff;
}
#output {
  flex-grow: 1;
  overflow-y: auto;
  white-space: pre-wrap;
  line-height: 1.4;
}
.output-entry {
  margin-bottom: 1rem;
  padding: 0.5rem;
  border-left: 2px solid #00ffaa66;
}
.entry-header {
  font-weight: bold;
  font-size: 1.1rem;
  color: #00ffff;
}
.entry-year {
  font-size: 0.9rem;
  color: #ffaa00;
  margin-left: 0.3rem;
}
.entry-tags {
  font-size: 0.85rem;
  color: #00ffaa;
  margin-top: 0.2rem;
}
.entry-desc {
  margin-top: 0.3rem;
}
.entry-links {
  margin-top: 0.2rem;
}
.collapsible {
  background-color: #00000022;
  cursor: pointer;
  padding: 0.3rem;
  margin-top: 0.3rem;
  border-left: 2px solid #00ffaa44;
}
.content {
  display: none;
  padding-left: 0.5rem;
}
#input-line {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 1rem;
}
#terminal-input {
  background: transparent;
  border: none;
  color: #00ff88;
  font-size: 1rem;
  flex-grow: 1;
  outline: none;
}
#credits {
  position: fixed;
  bottom: 0;
  left: 0;
  padding: 0.3rem 0.6rem;
  font-size: 0.65rem;
  color: #00ffaa88;
  background: #00000099;
  z-index: 100;
}
a {
  color: #00ffff;
  text-decoration: none;
}
a:hover { text-decoration: underline; }
</style>
</head>
<body>
<div id="terminal">
  <div id="header">Sparkpacket's Guide to the INTERNET!</div>
  <div id="output"></div>
  <div id="input-line">
    <span>$</span>
    <input type="text" id="terminal-input" placeholder="Type a term, or 'help' for commands..." autofocus />
  </div>
  <div id="credits">
    <small>
      Based off of The Hackerâ€™s Dictionary (1975), The Hitchhikerâ€™s Guide to the Galaxy (1979), and many other sources.<br/>
      Started by SPARKPACKET, using AI. Now being helped by: <span id="contributors">Fredoka,</span>
    </small>
  </div>
</div>

<script>
const input = document.getElementById('terminal-input');
const output = document.getElementById('output');

let dictionary = {};
let browserMode = "automatic";
let commandHistory = [];
let historyIndex = -1;

// Load handmade entries
fetch('data/entries.json')
  .then(res => res.json())
  .then(data => dictionary = data)
  .catch(err => log(`Error loading dictionary: ${err}`, true));

// Log function
function log(html, error=false) {
  const entry = document.createElement('div');
  entry.className = "output-entry";
  entry.style.color = error ? "#ff5555" : "#00ff88";
  entry.innerHTML = html;
  output.appendChild(entry);
  output.scrollTop = output.scrollHeight;
}

// Input handling
input.addEventListener('keydown', e => {
  if(e.key==='Enter'){
    const query = input.value.trim().toLowerCase();
    if(!query) return;
    commandHistory.push(query);
    historyIndex = commandHistory.length;
    input.value='';
    handleQuery(query);
  }
  if(e.key==='ArrowUp'){ if(historyIndex>0){historyIndex--;input.value=commandHistory[historyIndex];}}
  if(e.key==='ArrowDown'){ 
    if(historyIndex<commandHistory.length-1){historyIndex++;input.value=commandHistory[historyIndex];} 
    else {historyIndex=commandHistory.length; input.value='';}
  }
});

// Handle queries
function handleQuery(query){
  if(query==="help"){
    log(`Commands:
- help : Show this help
- list : List handmade entries
- clear : Clear terminal
- browsertype : Toggle mode (automatic/handmade)
- history : Previous searches
- tags [tag] : Search by tag
- random : Random entry
- timeline [year] : Show timeline
- [term] : Search term`);
    return;
  }
  if(query==="clear"){ output.innerHTML=""; return; }
  if(query==="browsertype"){ browserMode = browserMode==="automatic"?"handmade":"automatic"; log(`Browser type toggled. Current mode: ${browserMode.toUpperCase()}`); return;}
  if(query==="list"){ 
    if(browserMode==="handmade"){ log("Handmade entries:\n"+Object.keys(dictionary).map(k=>"- "+k).join("\n")); } 
    else{ log("> List unavailable in automatic mode."); } 
    return;
  }
  if(query==="history"){ 
    if(commandHistory.length===0) log("> No previous commands.");
    else log("> History:\n"+commandHistory.join("\n")); 
    return;
  }
  if(query.startsWith("tags ")){
    const tagQ = query.split(" ")[1];
    if(browserMode==="handmade"){
      const tagged = Object.keys(dictionary).filter(k=>dictionary[k].tags?.includes(tagQ));
      if(tagged.length>0) log(`Entries with tag "${tagQ}":\n`+tagged.join(", "));
      else log(`No entries found with tag "${tagQ}".`);
    } else { log("> Tags only in handmade mode."); }
    return;
  }
  if(query==="random"){
    if(browserMode==="handmade"){
      const keys = Object.keys(dictionary);
      const randKey = keys[Math.floor(Math.random()*keys.length)];
      showEntry(randKey,dictionary[randKey]);
    } else { log("> Random only in handmade mode."); }
    return;
  }
  if(query.startsWith("timeline")){
    if(browserMode==="handmade"){
      const yearQuery = query.split(" ")[1];
      const sorted = Object.entries(dictionary)
        .filter(([k,v])=>!yearQuery || v.year==yearQuery)
        .sort((a,b)=> (a[1].year||0)-(b[1].year||0));
      if(sorted.length===0) log("> No entries found for that year/tag.");
      else {
        log("Timeline view:");
        sorted.forEach(([k,v])=>showEntry(k,v,true));
      }
    } else { log("> Timeline only in handmade mode."); }
    return;
  }

  // Search term
  if(browserMode==="handmade"){
    const entry=dictionary[query];
    if(entry) showEntry(query,entry);
    else{
      const suggestions = Object.keys(dictionary).filter(k=>k.includes(query)).slice(0,5);
      if(suggestions.length>0) log(`> ${query} not found. Did you mean:\n${suggestions.join(", ")} ?`);
      else log(`> ${query} not found.`,true);
    }
  } else { fetchAutomatic(query); }
}

// Display single entry
function showEntry(key,entry,inline=false){
  const html = `<div class="entry-header">${key.toUpperCase()} ${entry.year?'<span class="entry-year">('+entry.year+')</span>':''}</div>
  <div class="entry-desc">${entry.desc}</div>
  ${entry.tags?'<div class="entry-tags">Tags: '+entry.tags.join(", ")+'</div>':''}
  ${entry.links?'<div class="entry-links">'+entry.links.map(l=>`ðŸ”— <a href="${l}" target="_blank">${l}</a>`).join("<br>")+'</div>':''}`;
  if(inline) log(html); else log(html);
}

// Automatic multi-source fetching
async function fetchAutomatic(query){
  log(`Searching for "${query}" from multiple sources...`);
  try{
    const wiki = await fetch(`https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(query)}`).then(r=>r.json());
    const wikiText = wiki.extract||"No Wikipedia summary.";
    const wikiLink = wiki.content_urls?.desktop?.page||"";
    log(`<div class="collapsible">Wikipedia</div><div class="content">${wikiText}<br>${wikiLink?`ðŸ”— <a href="${wikiLink}" target="_blank">${wikiLink}</a>`:""}</div>`);

    const ddg = await fetch(`https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json&no_html=1&skip_disambig=1`).then(r=>r.json());
    if(ddg.AbstractText) log(`<div class="collapsible">DuckDuckGo</div><div class="content">${ddg.AbstractText}<br>ðŸ”— <a href="${ddg.AbstractURL}" target="_blank">${ddg.AbstractURL}</a></div>`);

    // Make collapsible work
    document.querySelectorAll(".collapsible").forEach(c=>{
      c.onclick = ()=>{ const content=c.nextElementSibling; content.style.display=content.style.display==="block"?"none":"block";}
    });
  } catch(err){ log(`Error fetching automatic info: ${err}`,true);}
}
</script>
</body>
</html>
