<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sparkpacketâ€™s Guide to the INTERNET!</title>
<style>
body {
  margin: 0;
  font-family: monospace;
  background: black;
  color: #00ff88;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  overflow: hidden;
}
#terminal {
  width: 100%;
  max-width: 900px;
  height: 100vh;
  padding: 1rem;
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  overflow-y: auto;
  position: relative;
}
#header {
  font-size: 1.4rem;
  color: #00ffff;
  margin-bottom: 1rem;
  text-shadow: 0 0 6px #00ffff;
}
#output {
  flex-grow: 1;
  overflow-y: auto;
  white-space: pre-wrap;
  line-height: 1.4;
}
.output-entry {
  margin-bottom: 1rem;
  padding: 0.5rem;
  border-left: 2px solid #00ffaa66;
}
.entry-header {
  font-weight: bold;
  font-size: 1.1rem;
  color: #00ffff;
}
.entry-year {
  font-size: 0.9rem;
  color: #ffaa00;
  margin-left: 0.3rem;
}
.entry-tags {
  font-size: 0.85rem;
  color: #00ffaa;
  margin-top: 0.2rem;
}
.entry-desc {
  margin-top: 0.3rem;
}
.entry-links {
  margin-top: 0.2rem;
}
.collapsible {
  background-color: #00000022;
  cursor: pointer;
  padding: 0.3rem;
  margin-top: 0.3rem;
  border-left: 2px solid #00ffaa44;
}
.content {
  display: none;
  padding-left: 0.5rem;
}
#input-line {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 1rem;
}
#terminal-input {
  background: transparent;
  border: none;
  color: #00ff88;
  font-size: 1rem;
  flex-grow: 1;
  outline: none;
}
#credits {
  position: fixed;
  bottom: 0;
  left: 0;
  padding: 0.3rem 0.6rem;
  font-size: 0.65rem;
  color: #00ffaa88;
  background: #00000099;
  z-index: 100;
}
a { color: #00ffff; text-decoration: none; }
a:hover { text-decoration: underline; }
</style>
</head>
<body>
<div id="terminal">
  <div id="header">Sparkpacket's Guide to the INTERNET!</div>
  <div id="output"></div>
  <div id="input-line">
    <span>$</span>
    <input type="text" id="terminal-input" placeholder="Type a term, or 'help' for commands..." autofocus />
  </div>
  <div id="credits">
    <small>
      Based off of The Hackerâ€™s Dictionary (1975), The Hitchhikerâ€™s Guide to the Galaxy (1979), and many other sources.<br/>
      Started by SPARKPACKET, using AI. Now being helped by: <span id="contributors">Fredoka,</span>
    </small>
  </div>
</div>

<script>
const input = document.getElementById('terminal-input');
const output = document.getElementById('output');

let dictionary = {};
let browserMode = "automatic";
let commandHistory = [];
let historyIndex = -1;

// Load handmade entries
fetch('data/entries.json')
  .then(res => res.json())
  .then(data => dictionary = data)
  .catch(err => log(`Error loading dictionary: ${err}`, true));

// Logging
function log(html,error=false){
  const entry=document.createElement('div');
  entry.className="output-entry";
  entry.style.color=error?"#ff5555":"#00ff88";
  entry.innerHTML=html;
  output.appendChild(entry);
  output.scrollTop=output.scrollHeight;
}

// Command handling
input.addEventListener('keydown',e=>{
  if(e.key==='Enter'){
    const query=input.value.trim().toLowerCase();
    if(!query) return;
    commandHistory.push(query);
    historyIndex=commandHistory.length;
    input.value='';
    handleQuery(query);
  }
  if(e.key==='ArrowUp'){ if(historyIndex>0){historyIndex--;input.value=commandHistory[historyIndex];}}
  if(e.key==='ArrowDown'){ if(historyIndex<commandHistory.length-1){historyIndex++;input.value=commandHistory[historyIndex];} else {historyIndex=commandHistory.length; input.value='';}}
});

// Built-in commands
function handleQuery(query){
  if(query==="help"){ log(`Commands:
- help : Show this help
- list : List handmade entries
- clear : Clear terminal
- browsertype : Toggle mode (automatic/handmade)
- history : Previous searches
- tags [tag] : Search by tag
- random : Random entry
- timeline [year] : Show timeline
- [term] : Search term`); return; }
  if(query==="clear"){ output.innerHTML=""; return; }
  if(query==="browsertype"){ browserMode=browserMode==="automatic"?"handmade":"automatic"; log(`Browser type toggled. Current mode: ${browserMode.toUpperCase()}`); return;}
  if(query==="list"){ if(browserMode==="handmade"){ log("Handmade entries:\n"+Object.keys(dictionary).map(k=>"- "+k).join("\n")); } else{ log("> List unavailable in automatic mode."); } return;}
  if(query==="history"){ if(commandHistory.length===0) log("> No previous commands."); else log("> History:\n"+commandHistory.join("\n")); return;}
  if(query.startsWith("tags ")){
    const tagQ=query.split(" ")[1];
    if(browserMode==="handmade"){
      const tagged=Object.keys(dictionary).filter(k=>dictionary[k].tags?.includes(tagQ));
      if(tagged.length>0) log(`Entries with tag "${tagQ}":\n`+tagged.join(", ")); else log(`No entries found with tag "${tagQ}".`);
    } else log("> Tags only in handmade mode."); return;
  }
  if(query==="random"){
    if(browserMode==="handmade"){ const keys=Object.keys(dictionary); const randKey=keys[Math.floor(Math.random()*keys.length)]; showEntry(randKey,dictionary[randKey]); } else log("> Random only in handmade mode."); return;
  }
  if(query.startsWith("timeline")){
    if(browserMode==="handmade"){
      const yearQuery=query.split(" ")[1];
      const sorted=Object.entries(dictionary).filter(([k,v])=>!yearQuery||v.year==yearQuery).sort((a,b)=>(a[1].year||0)-(b[1].year||0));
      if(sorted.length===0) log("> No entries found for that year/tag.");
      else { log("Timeline view:"); sorted.forEach(([k,v])=>showEntry(k,v,true)); }
    } else log("> Timeline only in handmade mode."); return;
  }
  if(browserMode==="handmade"){
    const entry=dictionary[query];
    if(entry) showEntry(query,entry);
    else{ const suggestions=Object.keys(dictionary).filter(k=>k.includes(query)).slice(0,5); if(suggestions.length>0) log(`> ${query} not found. Did you mean:\n${suggestions.join(", ")} ?`); else log(`> ${query} not found.`,true);}
  } else fetchAutomatic(query);
}

// Display single entry
function showEntry(key,entry,inline=false){
  const html=`<div class="entry-header">${key.toUpperCase()} ${entry.year?'<span class="entry-year">('+entry.year+')</span>':''}</div>
  <div class="entry-desc">${entry.desc}</div>
  ${entry.tags?'<div class="entry-tags">Tags: '+entry.tags.join(", ")+'</div>':''}
  ${entry.links?'<div class="entry-links">'+entry.links.map(l=>`ðŸ”— <a href="${l}" target="_blank">${l}</a>`).join("<br>")+'</div>':''}`;
  log(html);
}

// 20+ API scaffold
const apis=[
  {name:"Wikipedia",fetcher:async(q)=>{ const r=await fetch(`https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(q)}`); const d=await r.json(); return {text:d.extract||"No summary",link:d.content_urls?.desktop?.page||""}; }},
  {name:"DuckDuckGo",fetcher:async(q)=>{ const r=await fetch(`https://api.duckduckgo.com/?q=${encodeURIComponent(q)}&format=json&no_html=1&skip_disambig=1`); const d=await r.json(); return {text:d.AbstractText||"No summary",link:d.AbstractURL||""}; }},
  {name:"MDN",fetcher:async(q)=>{ return {text:"MDN summary placeholder",link:"https://developer.mozilla.org/en-US/search?q="+encodeURIComponent(q)}; }},
  {name:"Archive.org",fetcher:async(q)=>{ return {text:"Archive.org placeholder",link:"https://archive.org/search.php?query="+encodeURIComponent(q)}; }},
  {name:"StackOverflow",fetcher:async(q)=>{ return {text:"StackOverflow placeholder",link:"https://stackoverflow.com/search?q="+encodeURIComponent(q)}; }},
  {name:"GitHub Repos",fetcher:async(q)=>{ return {text:"GitHub placeholder",link:"https://github.com/search?q="+encodeURIComponent(q)}; }},
  {name:"Reddit",fetcher:async(q)=>{ return {text:"Reddit placeholder",link:"https://www.reddit.com/search/?q="+encodeURIComponent(q)}; }},
  {name:"Wiktionary",fetcher:async(q)=>{ return {text:"Wiktionary placeholder",link:"https://en.wiktionary.org/wiki/"+encodeURIComponent(q)}; }},
  {name:"YouTube",fetcher:async(q)=>{ return {text:"YouTube placeholder",link:"https://www.youtube.com/results?search_query="+encodeURIComponent(q)}; }},
  {name:"News",fetcher:async(q)=>{ return {text:"News placeholder",link:"https://news.google.com/search?q="+encodeURIComponent(q)}; }},
  {name:"Quora",fetcher:async(q)=>{ return {text:"Quora placeholder",link:"https://www.quora.com/search?q="+encodeURIComponent(q)}; }},
  {name:"OpenAI Summary",fetcher:async(q)=>{ return {text:"AI summary placeholder",link:"#"}; }},
  {name:"TechCrunch",fetcher:async(q)=>{ return {text:"TechCrunch placeholder",link:"https://techcrunch.com/search/"+encodeURIComponent(q)}; }},
  {name:"HackerNews",fetcher:async(q)=>{ return {text:"HackerNews placeholder",link:"https://news.ycombinator.com/"}; }},
  {name:"Wikipedia Images",fetcher:async(q)=>{ return {text:"Image summary placeholder",link:"https://en.wikipedia.org/wiki/"+encodeURIComponent(q)}; }},
  {name:"Reddit Comments",fetcher:async(q)=>{ return {text:"Reddit comments placeholder",link:"https://www.reddit.com/search/?q="+encodeURIComponent(q)}; }},
  {name:"GitHub Issues",fetcher:async(q)=>{ return {text:"GitHub issues placeholder",link:"https://github.com/search?q="+encodeURIComponent(q)+"&type=issues"}; }},
  {name:"Google Books",fetcher:async(q)=>{ return {text:"Google Books placeholder",link:"https://www.google.com/search?tbm=bks&q="+encodeURIComponent(q)}; }},
  {name:"StackExchange",fetcher:async(q)=>{ return {text:"StackExchange placeholder",link:"https://stackexchange.com/search?q="+encodeURIComponent(q)}; }},
  {name:"Internet Archive Text",fetcher:async(q)=>{ return {text:"Internet Archive Text placeholder",link:"https://archive.org/search.php?query="+encodeURIComponent(q)}; }}
];

// Multi-API fetch
async function fetchAutomatic(query){
  log(`Searching "${query}" across multiple sources...`);
  const results=await Promise.all(apis.map(api=>api.fetcher(query).catch(e=>({text:"Error",link:""}))));
  results.forEach((res,i)=>{
    const html=`<div class="collapsible">${apis[i].name}</div><div class="content">${res.text}<br>${res.link?`ðŸ”— <a href="${res.link}" target="_blank">${res.link}</a>`:""}</div>`;
    log(html);
  });
  document.querySelectorAll(".collapsible").forEach(c=>{c.onclick=()=>{const content=c.nextElementSibling;content.style.display=content.style.display==="block"?"none":"block";}});
}
</script>
</body>
</html>
